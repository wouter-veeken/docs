{
    "docs": [
        {
            "location": "/", 
            "text": "About\n\n\nVale is an open source linter for prose\u2014no matter if it's plain text, markup or source-code comments. It's built around a plugin system that allows it to lint against arbitrary rules. In practice, this means that it can help you adhere to entire editorial style guides or simply break writer-specific bad habits.\n\n\n\n\nInstallation\n\n\nVale works on Windows, macOS, and Linux. Installation is straightforward and there are a few options to choose from, as discussed below.\n\n\nWindows Installer\n\n\n\n\nNOTE\n\n\nYou may be warned about the package coming from an \"unidentified developer.\" If you're not comfortable with this, you can install manually (see below).\n\n\n\n\nThe easiest way to install on Windows is to use the Windows Installer package, \nvale.msi\n (which you'll find on the \nreleases page\n).\n\n\nHomebrew (macOS)\n\n\nThe easiest way to install on macOS is through \nHomebrew\n:\n\n\n$ brew tap ValeLint/vale\n$ brew install vale\n\n\n\n\nManually (Windows, macOS \n Linux)\n\n\nDownload a binary from the \nreleases page\n for your OS.\n\n\nYou can put it anywhere you want. If you're not sure how to get started, check out one of our guides below.\n\n\n\n\nGetting Started with Vale (Windows)\n (Coming soon.)\n\n\nGetting Started with Vale (macOS)\n\n\nGetting Started with Vale (Ubuntu)\n (Coming soon.)\n\n\n\n\nUsing Go (Windows, macOS \n Linux)\n\n\nIf you have \nGo\n installed and configured, you can install with \ngo get\n:\n\n\n$ go get github.com/ValeLint/vale", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#about", 
            "text": "Vale is an open source linter for prose\u2014no matter if it's plain text, markup or source-code comments. It's built around a plugin system that allows it to lint against arbitrary rules. In practice, this means that it can help you adhere to entire editorial style guides or simply break writer-specific bad habits.", 
            "title": "About"
        }, 
        {
            "location": "/#installation", 
            "text": "Vale works on Windows, macOS, and Linux. Installation is straightforward and there are a few options to choose from, as discussed below.  Windows Installer   NOTE  You may be warned about the package coming from an \"unidentified developer.\" If you're not comfortable with this, you can install manually (see below).   The easiest way to install on Windows is to use the Windows Installer package,  vale.msi  (which you'll find on the  releases page ).  Homebrew (macOS)  The easiest way to install on macOS is through  Homebrew :  $ brew tap ValeLint/vale\n$ brew install vale  Manually (Windows, macOS   Linux)  Download a binary from the  releases page  for your OS.  You can put it anywhere you want. If you're not sure how to get started, check out one of our guides below.   Getting Started with Vale (Windows)  (Coming soon.)  Getting Started with Vale (macOS)  Getting Started with Vale (Ubuntu)  (Coming soon.)   Using Go (Windows, macOS   Linux)  If you have  Go  installed and configured, you can install with  go get :  $ go get github.com/ValeLint/vale", 
            "title": "Installation"
        }, 
        {
            "location": "/usage/", 
            "text": "Using the CLI\n\n\nvale\n is a command-line tool for linting prose against style guidelines. Its general usage information is below:\n\n\n$ vale --help\nNAME:\n   vale - A command-line linter for prose.\n\nUSAGE:\n   vale [global options] command [command options] [arguments...]\n\nVERSION:\n   vX.X.X\n\nCOMMANDS:\n     dump-config, dc  Dumps configuration options to stdout and exits\n     new              Generates a template for the given extension point\n     help, h          Shows a list of commands or help for one command\n\nGLOBAL OPTIONS:\n   --glob value     a glob pattern (e.g., --glob=\n*.{md,txt}\n) (default: \n*\n)\n   --output value   output style (\nline\n, \nJSON\n, or \ncontext\n) (default: \nCLI\n)\n   --ext value      extension to associate with stdin (default: \n.txt\n)\n   --no-wrap        don\nt wrap CLI output\n   --no-exit        don\nt return a nonzero exit code on lint errors\n   --sort           sort files by their name in output\n   --ignore-syntax  lint all files line-by-line\n   --help, -h       show help\n   --version, -v    print the version\n\n\nYou can run Vale on single files or entire directories. You can also lint only files matching a particular glob:\n\n\n$ vale --glob\n=\n*.{md,rst}\n some-directory\n\n\n\n\nOr exclude files matching a particular glob:\n\n\n$ vale --glob\n=\n!*.min.js\n some-directory\n\n\n\n\nVale ships with the following rules:\n\n\n\n\n\n\n\n\n\n\n\nRule\n\n\nDescription\n\n\nSeverity\n\n\n\n\n\n\n\n\n\n\nEditorializing\n\n\nThe use of adverbs or phrases to highlight something as particularly significant.\n\n\nwarning\n\n\n\n\n\n\nGenderBias\n\n\nThe unnecessary use of gender-specific language.\n\n\nerror\n\n\n\n\n\n\nHedging\n\n\nThe use of phrases, like \"in my opinion,\" that weaken meaning.\n\n\nwarning\n\n\n\n\n\n\nRedundancy\n\n\nThe use of phrases like \"ATM machine.\"\n\n\nerror\n\n\n\n\n\n\nRepetition\n\n\nInstances of repeated words, which are often referred to as lexical illusions.\n\n\nerror\n\n\n\n\n\n\nUncomparables\n\n\nThe use of phrases like \"very unique.\"\n\n\nerror\n\n\n\n\n\n\n\n\n\n\n\nBut Vale's true strength lies in its ability to support \nyour\n style. See \nStyles\n for more information on creating your own style guide.\n\n\nEditor Integration", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#using-the-cli", 
            "text": "vale  is a command-line tool for linting prose against style guidelines. Its general usage information is below:  $ vale --help\nNAME:\n   vale - A command-line linter for prose.\n\nUSAGE:\n   vale [global options] command [command options] [arguments...]\n\nVERSION:\n   vX.X.X\n\nCOMMANDS:\n     dump-config, dc  Dumps configuration options to stdout and exits\n     new              Generates a template for the given extension point\n     help, h          Shows a list of commands or help for one command\n\nGLOBAL OPTIONS:\n   --glob value     a glob pattern (e.g., --glob= *.{md,txt} ) (default:  * )\n   --output value   output style ( line ,  JSON , or  context ) (default:  CLI )\n   --ext value      extension to associate with stdin (default:  .txt )\n   --no-wrap        don t wrap CLI output\n   --no-exit        don t return a nonzero exit code on lint errors\n   --sort           sort files by their name in output\n   --ignore-syntax  lint all files line-by-line\n   --help, -h       show help\n   --version, -v    print the version \nYou can run Vale on single files or entire directories. You can also lint only files matching a particular glob:  $ vale --glob = *.{md,rst}  some-directory  Or exclude files matching a particular glob:  $ vale --glob = !*.min.js  some-directory  Vale ships with the following rules:      Rule  Description  Severity      Editorializing  The use of adverbs or phrases to highlight something as particularly significant.  warning    GenderBias  The unnecessary use of gender-specific language.  error    Hedging  The use of phrases, like \"in my opinion,\" that weaken meaning.  warning    Redundancy  The use of phrases like \"ATM machine.\"  error    Repetition  Instances of repeated words, which are often referred to as lexical illusions.  error    Uncomparables  The use of phrases like \"very unique.\"  error      But Vale's true strength lies in its ability to support  your  style. See  Styles  for more information on creating your own style guide.", 
            "title": "Using the CLI"
        }, 
        {
            "location": "/usage/#editor-integration", 
            "text": "", 
            "title": "Editor Integration"
        }, 
        {
            "location": "/config/", 
            "text": "Basics\n\n\nVale looks for its configuration in a file named \n.vale.ini\n or \n_vale.ini\n. This file may be located in the current working directory, a parent directory or \n$HOME\n. If more than one configuration file is present, the closest one takes precedence.\n\n\nThe basic structure of a configuration file is as follows:\n\n\n# Core settings\n\n\nStylesPath\n \n=\n \npath/to/my/project/styles/directory\n\n\nMinAlertLevel\n \n=\n \nwarning # suggestion, warning or error\n\n\n\n# Global settings (applied to every syntax)\n\n\n[*]\n\n\n# List of styles to load\n\n\nBasedOnStyles\n \n=\n \nvale, MyCustomStyle\n\n\n# Style.Rule = {YES, NO} to enable or disable a specific rule\n\n\nvale.Editorializing\n \n=\n \nYES\n\n\n# You can also change the level associated with a rule\n\n\nvale.Hedging\n \n=\n \nerror\n\n\n...\n\n\n\n# Syntax-specific settings\n\n\n# These overwrite any conflicting global settings\n\n\n[*.{md,txt}]\n\n\n...\n\n\n\n\n\nUsing Comments\n\n\n\n\nNOTE\n\n\nreStructuredText uses \n.. vale off\n style comments.\n\n\n\n\nVale also supports context-specific configuration in Markdown, HTML, and reStructuredText documents:\n\n\n!-- vale off --\n\n\nThis is some text\n\nmore text here...\n\n\n!-- vale on --\n\n\n\n!-- vale Style.Rule = NO --\n\n\nThis is some text\n\n\n!-- vale Style.Rule = YES --\n\n\n\n\n\nExamples\n\n\nLet's say we're working on a project with Python source code and reStructuredText documentation. Assuming we're using styles named \nbase\n (with general style rules) and \nProjectName\n (with project-specific rules), we could have the following configuration:\n\n\nStylesPath\n \n=\n \nstyles\n\n\n\n[*.{rst,py}]\n\n\nBasedOnStyles\n \n=\n \nbase, ProjectName\n\n\n\n\n\nIf we add another style named \ndocs\n with rules we only want to apply to our documentation, we could change it to:\n\n\n[*.rst]\n\n\nBasedOnStyles\n \n=\n \nbase, ProjectName, docs\n\n\n\n[*.py]\n\n\nBasedOnStyles\n \n=\n \nbase, ProjectName\n\n\ndocs.SomeRule\n \n=\n \nYES # there\ns actually one rule we want", 
            "title": "Configuration"
        }, 
        {
            "location": "/config/#basics", 
            "text": "Vale looks for its configuration in a file named  .vale.ini  or  _vale.ini . This file may be located in the current working directory, a parent directory or  $HOME . If more than one configuration file is present, the closest one takes precedence.  The basic structure of a configuration file is as follows:  # Core settings  StylesPath   =   path/to/my/project/styles/directory  MinAlertLevel   =   warning # suggestion, warning or error  # Global settings (applied to every syntax)  [*]  # List of styles to load  BasedOnStyles   =   vale, MyCustomStyle  # Style.Rule = {YES, NO} to enable or disable a specific rule  vale.Editorializing   =   YES  # You can also change the level associated with a rule  vale.Hedging   =   error  ...  # Syntax-specific settings  # These overwrite any conflicting global settings  [*.{md,txt}]  ...", 
            "title": "Basics"
        }, 
        {
            "location": "/config/#using-comments", 
            "text": "NOTE  reStructuredText uses  .. vale off  style comments.   Vale also supports context-specific configuration in Markdown, HTML, and reStructuredText documents:  !-- vale off -- \n\nThis is some text\n\nmore text here... !-- vale on --  !-- vale Style.Rule = NO -- \n\nThis is some text !-- vale Style.Rule = YES --", 
            "title": "Using Comments"
        }, 
        {
            "location": "/config/#examples", 
            "text": "Let's say we're working on a project with Python source code and reStructuredText documentation. Assuming we're using styles named  base  (with general style rules) and  ProjectName  (with project-specific rules), we could have the following configuration:  StylesPath   =   styles  [*.{rst,py}]  BasedOnStyles   =   base, ProjectName   If we add another style named  docs  with rules we only want to apply to our documentation, we could change it to:  [*.rst]  BasedOnStyles   =   base, ProjectName, docs  [*.py]  BasedOnStyles   =   base, ProjectName  docs.SomeRule   =   YES # there s actually one rule we want", 
            "title": "Examples"
        }, 
        {
            "location": "/formats/", 
            "text": "Overview\n\n\nVale is \"syntax aware,\" which means that it's capable of both applying rules to and ignoring certain sections of text. This functionality is implemented through a \nscoping\n system. A scope (i.e., a particular section of text) is specified through a \nselector\n such as \nparagraph.rst\n, which indicates that the rule applies to all paragraphs in reStructuredText files. Here are a few examples:\n\n\n\n\ncomment\n matches all source code comments;\n\n\ncomment.line\n matches all source code line comments;\n\n\nheading.md\n matches all Markdown headings; and\n\n\ntext.html\n matches all HTML scopes.\n\n\n\n\nThe table below summarizes all available scopes.\n\n\n\n\n\n\n\n\nFormat\n\n\nScopes\n\n\n\n\n\n\n\n\n\n\nmarkup\n\n\nheading\n, \ntable.header\n, \ntable.cell\n, \nlist\n, \nparagraph\n, \nsentence\n\n\n\n\n\n\ncode\n\n\ncomment.line\n, \ncomment.block\n\n\n\n\n\n\nplain text\n\n\ntext\n\n\n\n\n\n\n\n\nMarkdown\n\n\nVale has built-in support for GitHub-Flavored Markdown. By default, it ignores indented blocks, fenced blocks, and code spans.\n\n\nHTML\n\n\nVale has built-in support for HTML. By default, it ignores \nscript\n, \nstyle\n, \npre\n, \ncode\n, and \ntt\n tags.\n\n\nreStructuredText\n\n\nVale supports reStructuredText through the external program \nrst2html\n. If you have \nSphinx\n or \ndocutils\n installed, you shouldn't need to install \nrst2html\n separately.\n\n\nBy default, it ignores literal blocks, inline literals, and \ncode-block\ns.\n\n\nAsciiDoc\n\n\nVale supports AsciiDoc through the external program \nAsciiDoctor\n. By default, it ignores listing blocks and inline literals.\n\n\nCode\n\n\n\n\n\n\n\n\n\n\n\nSyntax\n\n\nExtensions\n\n\nTokens (scope)\n\n\n\n\n\n\n\n\n\n\nC\n\n\n.c\n, \n.h\n\n\n//\n (\ntext.comment.line.ext\n), \n/*...*/\n (\ntext.comment.line.ext\n), \n/*\n (\ntext.comment.block.ext\n)\n\n\n\n\n\n\nC#\n\n\n.cs\n, \n.csx\n\n\n//\n (\ntext.comment.line.ext\n), \n/*...*/\n (\ntext.comment.line.ext\n), \n/*\n (\ntext.comment.block.ext\n)\n\n\n\n\n\n\nC++\n\n\n.cpp\n, \n.cc\n, \n.cxx\n, \n.hpp\n\n\n//\n (\ntext.comment.line.ext\n), \n/*...*/\n (\ntext.comment.line.ext\n), \n/*\n (\ntext.comment.block.ext\n)\n\n\n\n\n\n\nCSS\n\n\n.css\n\n\n/*...*/\n (\ntext.comment.line.ext\n), \n/*\n (\ntext.comment.block.ext\n)\n\n\n\n\n\n\nGo\n\n\n.go\n\n\n//\n (\ntext.comment.line.ext\n), \n/*...*/\n (\ntext.comment.line.ext\n), \n/*\n (\ntext.comment.block.ext\n)\n\n\n\n\n\n\nHaskell\n\n\n.hs\n\n\n--\n (\ntext.comment.line.ext\n), \n{-\n (\ntext.comment.block.ext\n)\n\n\n\n\n\n\nJava\n\n\n.java\n, \n.bsh\n\n\n//\n (\ntext.comment.line.ext\n), \n/*...*/\n (\ntext.comment.line.ext\n), \n/*\n (\ntext.comment.block.ext\n)\n\n\n\n\n\n\nJavaScript\n\n\n.js\n\n\n//\n (\ntext.comment.line.ext\n), \n/*...*/\n (\ntext.comment.line.ext\n), \n/*\n (\ntext.comment.block.ext\n)\n\n\n\n\n\n\nLESS\n\n\n.less\n\n\n//\n(\ntext.comment.line.ext\n), \n/*...*/\n (\ntext.comment.line.ext\n), \n/*\n (\ntext.comment.block.ext\n)\n\n\n\n\n\n\nLua\n\n\n.lua\n\n\n--\n (\ntext.comment.line.ext\n), \n--[[\n (\ntext.comment.block.ext\n)\n\n\n\n\n\n\nPerl\n\n\n.pl\n, \n.pm\n, \n.pod\n\n\n#\n (\ntext.comment.line.ext\n)\n\n\n\n\n\n\nPHP\n\n\n.php\n\n\n//\n (\ntext.comment.line.ext\n), \n#\n (\ntext.comment.line.ext\n), \n/*...*/\n (\ntext.comment.line.ext\n), \n/*\n (\ntext.comment.block.ext\n)\n\n\n\n\n\n\nPython\n\n\n.py\n, \n.py3\n, \n.pyw\n, \n.pyi\n, \n.rpy\n\n\n#\n (\ntext.comment.line.ext\n), \n (\ntext.comment.block.ext\n)\n\n\n\n\n\n\nR\n\n\n.r\n, \n.R\n\n\n#\n (\ntext.comment.line.ext\n)\n\n\n\n\n\n\nRuby\n\n\n.rb\n\n\n#\n (\ntext.comment.line.ext\n), \n^=begin\n (\ntext.comment.block.ext\n)\n\n\n\n\n\n\nSass\n\n\n.sass\n\n\n//\n (\ntext.comment.line.ext\n), \n/*...*/\n (\ntext.comment.line.ext\n), \n/*\n (\ntext.comment.block.ext\n)\n\n\n\n\n\n\nScala\n\n\n.scala\n, \n.sbt\n\n\n//\n(\ntext.comment.line.ext\n),\n\n\n\n\n\n\nSwift\n\n\n.swift\n\n\n//\n (\ntext.comment.line.ext\n), \n/*...*/\n (\ntext.comment.line.ext\n), \n/*\n (\ntext.comment.block.ext\n)", 
            "title": "File Formats"
        }, 
        {
            "location": "/formats/#overview", 
            "text": "Vale is \"syntax aware,\" which means that it's capable of both applying rules to and ignoring certain sections of text. This functionality is implemented through a  scoping  system. A scope (i.e., a particular section of text) is specified through a  selector  such as  paragraph.rst , which indicates that the rule applies to all paragraphs in reStructuredText files. Here are a few examples:   comment  matches all source code comments;  comment.line  matches all source code line comments;  heading.md  matches all Markdown headings; and  text.html  matches all HTML scopes.   The table below summarizes all available scopes.     Format  Scopes      markup  heading ,  table.header ,  table.cell ,  list ,  paragraph ,  sentence    code  comment.line ,  comment.block    plain text  text", 
            "title": "Overview"
        }, 
        {
            "location": "/formats/#markdown", 
            "text": "Vale has built-in support for GitHub-Flavored Markdown. By default, it ignores indented blocks, fenced blocks, and code spans.", 
            "title": "Markdown"
        }, 
        {
            "location": "/formats/#html", 
            "text": "Vale has built-in support for HTML. By default, it ignores  script ,  style ,  pre ,  code , and  tt  tags.", 
            "title": "HTML"
        }, 
        {
            "location": "/formats/#restructuredtext", 
            "text": "Vale supports reStructuredText through the external program  rst2html . If you have  Sphinx  or  docutils  installed, you shouldn't need to install  rst2html  separately.  By default, it ignores literal blocks, inline literals, and  code-block s.", 
            "title": "reStructuredText"
        }, 
        {
            "location": "/formats/#asciidoc", 
            "text": "Vale supports AsciiDoc through the external program  AsciiDoctor . By default, it ignores listing blocks and inline literals.", 
            "title": "AsciiDoc"
        }, 
        {
            "location": "/formats/#code", 
            "text": "Syntax  Extensions  Tokens (scope)      C  .c ,  .h  //  ( text.comment.line.ext ),  /*...*/  ( text.comment.line.ext ),  /*  ( text.comment.block.ext )    C#  .cs ,  .csx  //  ( text.comment.line.ext ),  /*...*/  ( text.comment.line.ext ),  /*  ( text.comment.block.ext )    C++  .cpp ,  .cc ,  .cxx ,  .hpp  //  ( text.comment.line.ext ),  /*...*/  ( text.comment.line.ext ),  /*  ( text.comment.block.ext )    CSS  .css  /*...*/  ( text.comment.line.ext ),  /*  ( text.comment.block.ext )    Go  .go  //  ( text.comment.line.ext ),  /*...*/  ( text.comment.line.ext ),  /*  ( text.comment.block.ext )    Haskell  .hs  --  ( text.comment.line.ext ),  {-  ( text.comment.block.ext )    Java  .java ,  .bsh  //  ( text.comment.line.ext ),  /*...*/  ( text.comment.line.ext ),  /*  ( text.comment.block.ext )    JavaScript  .js  //  ( text.comment.line.ext ),  /*...*/  ( text.comment.line.ext ),  /*  ( text.comment.block.ext )    LESS  .less  // ( text.comment.line.ext ),  /*...*/  ( text.comment.line.ext ),  /*  ( text.comment.block.ext )    Lua  .lua  --  ( text.comment.line.ext ),  --[[  ( text.comment.block.ext )    Perl  .pl ,  .pm ,  .pod  #  ( text.comment.line.ext )    PHP  .php  //  ( text.comment.line.ext ),  #  ( text.comment.line.ext ),  /*...*/  ( text.comment.line.ext ),  /*  ( text.comment.block.ext )    Python  .py ,  .py3 ,  .pyw ,  .pyi ,  .rpy  #  ( text.comment.line.ext ),   ( text.comment.block.ext )    R  .r ,  .R  #  ( text.comment.line.ext )    Ruby  .rb  #  ( text.comment.line.ext ),  ^=begin  ( text.comment.block.ext )    Sass  .sass  //  ( text.comment.line.ext ),  /*...*/  ( text.comment.line.ext ),  /*  ( text.comment.block.ext )    Scala  .scala ,  .sbt  // ( text.comment.line.ext ),    Swift  .swift  //  ( text.comment.line.ext ),  /*...*/  ( text.comment.line.ext ),  /*  ( text.comment.block.ext )", 
            "title": "Code"
        }, 
        {
            "location": "/styles/", 
            "text": "Introduction\n\n\nVale is built around the notion of \"styles,\" which are directories containing individual \"rule\" definitions\nfor example, you might have a structure like\n\n\nstyles/\n\u251c\u2500\u2500 base/\n\u2502   \u251c\u2500\u2500 ComplexWords.yml\n\u2502   \u251c\u2500\u2500 SentenceLength.yml\n\u2502   ...\n\u251c\u2500\u2500 blog/\n\u2502   \u251c\u2500\u2500 TechTerms.yml\n\u2502   ...\n\u2514\u2500\u2500 docs/\n    \u251c\u2500\u2500 Branding.yml\n    ...\n\n\n\n\nwhere \nbase\n, \nblog\n, and \ndocs\n are your styles. The \nYAML\n files are rule definitions that include the following keys:\n\n\n\n\nextends\n: The type of check you're extending (see \nCreating a Style\n).\n\n\nmessage\n: A message to be displayed to the user.\n\n\nlevel\n: A severity level (suggestion, warning, or error).\n\n\nscope\n: The type of text the rule operates on (see \nFormats\n to learn about scoping).\n\n\ncode\n: \ntrue\n to include the content of code spans and \nfalse\n (the default) to ignore them.\n\n\n\n\nMany checks also include their own specific settings, which are discussed in more detail below.\n\n\nCreating a Style\n\n\nchecks\n offer a high-level way to extend Vale. They perform operations such as checking for consistency, counting occurrences, and suggesting changes.\n\n\nVale\n and its \nreference styles\n are examples of how you can write your own rules.\n\n\n\n\nNOTE\n\n\nVale uses Go's \nregexp\n package\n to evaluate all patterns in rule definitions. This means that lookarounds and backreferences are not supported.\n\n\n\n\nexistence\n\n\nextends\n:\n \nexistence\n\n\nmessage\n:\n \nConsider\n \nremoving\n \n%s\n\n\nignorecase\n:\n \ntrue\n\n\nlevel\n:\n \nwarning\n\n\ntokens\n:\n\n  \n-\n \nappear to be\n\n  \n-\n \narguably\n\n\n\n\n\nThe most common extension point is the \nexistence\n check. As its name implies, it looks for the \nexistence\n of particular strings.\n\n\nYou may define these strings as elements of lists named either \ntokens\n or \nraw\n. The former converts its elements into a word-bounded group by default. For instance,\n\n\nmessage\n:\n \nConsider\n \nremoving\n \n%s\n\n\ntokens\n:\n\n  \n-\n \nfoo\n\n  \n-\n \nbar\n\n  \n-\n \nbaz\n\n\n\nbecomes \n\\b(?:foo|bar|baz)\\b\n. You can also use the keys \nignorecase\n and \nnonword\n to add \n(?!)\n and drop the word boundaries, respectively.\n\n\nraw\n, on the other hand, simply concatenates its elements\nso, something like\n\n\nraw\n:\n\n  \n-\n \n(?:foo)\\sbar\n\n  \n-\n \n(baz)\n\n\n\nbecomes \n(?:foo)\\sbar(baz)\n.\n\n\nAn \nexistence\n expects its \nmessage\n to include a \n%s\n format specifier, which will be populated with the matched string. So, using the above example, \"Consider removing 'foo'\" will be printed if we find an occurrence of \"foo.\"\n\n\nsubstitution\n\n\nextends\n:\n \nsubstitution\n\n\nmessage\n:\n \nConsider using \n%s\n instead of \n%s\n\n\nignorecase\n:\n \ntrue\n\n\nlevel\n:\n \nwarning\n\n\nswap\n:\n\n  \nabundance\n:\n \nplenty\n\n  \naccelerate\n:\n \nspeed up\n\n\n\n\n\nA \nsubstitution\n check associates a string with a preferred form. If we want to suggest the use of \"plenty\" instead of \"abundance,\" for example, we'd write:\n\n\nswap\n:\n\n  \nabundance\n:\n \nplenty\n\n\n\n\n\nThe keys may be regular expressions, but they can't include nested capture groups:\n\n\nswap\n:\n\n  \n(?:give|gave)\n \nrise\n \nto\n:\n \nlead to\n \n# this is okay\n\n  \n(give|gave)\n \nrise\n \nto\n:\n \nlead to\n \n# this is bad!\n\n\n\n\n\nLike the \nexistence\n check, \nsubstitution\n accepts the keys \nignorecase\n and \nnonword\n.\n\n\nA \nsubstitution\n check can have one or two \n%s\n format specifiers in its \nmessage\n. This allows us to do either of the following:\n\n\nmessage\n:\n \nConsider\n \nusing\n \n%s\n \ninstead\n \nof\n \n%s\n\n\n# or\n\n\nmessage\n:\n \nConsider\n \nusing\n \n%s\n\n\n\n\n\noccurrence\n\n\nextends\n:\n \noccurrence\n\n\nmessage\n:\n \nSentences\n \nshould\n \nbe\n \nless\n \nthan\n \n25\n \nwords\n\n\nscope\n:\n \nsentence\n\n\nlevel\n:\n \nsuggestion\n\n\nmax\n:\n \n25\n\n\ntoken\n:\n \n\\b(\\w+)\\b\n\n\n\n\n\nAn \noccurrence\n check limits the number of times a particular token can appear in a given scope. In the example above, we're limiting the number of words per sentence.\n\n\nThis is the only check that doesn't accept a format specifier in its message.\n\n\nrepetition\n\n\nextends\n:\n \nrepetition\n\n\nmessage\n:\n \n%s\n \nis\n \nrepeated!\n\n\nlevel\n:\n \nerror\n\n\nscope\n:\n \nparagraph\n\n\nignorecase\n:\n \ntrue\n\n\ntokens\n:\n\n  \n-\n \n\\b(\\w+)\\b\n\n\n\n\n\nA \nrepetition\n  check  looks for repeated occurrences of its tokens. If \nignorecase\n is set to \ntrue\n, it'll convert all tokens to lower case for comparison purposes.\n\n\nconsistency\n\n\nextends\n:\n \nconsistency\n\n\nmessage\n:\n \nInconsistent\n \nspelling\n \nof\n \n%s\n\n\nlevel\n:\n \nwarning\n\n\nscope\n:\n \ntext\n\n\nignorecase\n:\n \ntrue\n\n\neither\n:\n\n  \nadvisor\n:\n \nadviser\n\n  \ncentre\n:\n \ncenter\n\n\n\n\n\nA \nconsistency\n check will ensure that a key and its value (e.g., \"advisor\" and \"adviser\") don't both occur in its scope.\n\n\nconditional\n\n\nextends\n:\n \nconditional\n\n\nmessage\n:\n \n%s\n \nhas\n \nno\n \ndefinition\n\n\nlevel\n:\n \nwarning\n\n\nscope\n:\n \ntext\n\n\nfirst\n:\n \n\\b([A-Z]{3,5})\\b\n\n\nsecond\n:\n \n(?:\\b[A-Z][a-z]+ )+\\(([A-Z]{3,5})\\)\n\n\nexceptions\n:\n\n  \n-\n \nABC\n\n\n\n\n\nA \nconditional\n check ensures that the existence of \nfirst\n implies the existence of \nsecond\n. For example, consider the following text:\n\n\n\n\n\n\n\nAccording to Wikipedia, the World Health Organization (WHO) is a specialized agency of the United Nations that is concerned with international public health. We can now use WHO because it has been defined, but we can't use DAFB because people may not know what it represents. We can use \nDAFB\n when it's presented as code, though.\n\n\n\n\n\n\n\nRunning \nvale\n on the above text with our example rule yields the following:\n\n\ntest.md:1:224:vale.UnexpandedAcronyms:\nDAFB\n has no definition\n\n\n\n\nA \nconditional\n check also takes an optional \nexceptions\n list. Any token listed as an exception won't be flagged.\n\n\ncapitalization\n\n\nextends\n:\n \ncapitalization\n\n\nmessage\n:\n \n%s\n \nshould\n \nbe\n \nin\n \ntitle\n \ncase\n\n\nlevel\n:\n \nwarning\n\n\nscope\n:\n \nheading\n\n\n# $title, $sentence, $lower, $upper, or a pattern.\n\n\nmatch\n:\n \n$title\n\n\nstyle\n:\n \nAP\n \n# AP or Chicago; only applies when match is set to $title.\n\n\n\n\n\ncapitalization\n checks that the text in the specified scope matches the case\nof \nmatch\n. There are a few pre-defined variables that can be passed as matches:\n\n\n\n\n\n\n\n$title\n: \"The Quick Brown Fox Jumps Over the Lazy Dog.\"\n\n\n$sentence\n: \"The quick brown fox jumps over the lazy dog.\"\n\n\n$lower\n: \"the quick brown fox jumps over the lazy dog.\"\n\n\n$upper\n: \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\"\n\n\n\n\nAdditionally, when using \nmatch: $title\n, you can specify a style of either \nAP\n or\n\nChicago\n.\n\n\nreadability\n\n\nextends\n:\n \nreadability\n\n\nmessage\n:\n \nGrade\n \nlevel\n \n(%s)\n \ntoo\n \nhigh!\n\n\nlevel\n:\n \nwarning\n\n\ngrade\n:\n \n8\n\n\nmetrics\n:\n\n  \n-\n \nFlesch-Kincaid\n\n  \n-\n \nGunning Fog\n\n\n\n\n\nreadability\n calculates a readability score according the specified metrics.\nThe supported tests are Gunning Fog, Coleman-Liau, Flesch-Kincaid, SMOG, and\nAutomated Readability.\n\n\nIf more than one is listed (as seen above), the scores will be averaged. This is\nalso the only extension point that doesn't accept a \nscope\n, as readability is\nalways calculated using the entire document.\n\n\ngrade\n is the highest acceptable score. Using the example above, a warning will\nbe issued if \ngrade\n exceeds 8.\n\n\n\n\n\nspelling\n\n\nextends\n:\n \nspelling\n\n\nmessage\n:\n \nDid\n \nyou\n \nreally\n \nmean\n \n%s\n?\n\n\nlevel\n:\n \nerror\n\n\nignore\n:\n \nci/vocab.txt\n\n\n\n\n\nspelling\n implements spell checking based on Hunspell-compatible dictionaries. By default, Vale includes \nen_US-web\nan up-to-date, actively maintained dictionary. However, you may also specify your own via the \ndic\n and \naff\n keys (the fully-qualified paths are required; e.g., \n/usr/share/hunspell/en_US.dic\n).\n\n\nspelling\n also accepts an \nignore\n file, which consists of one word per line to\nbe ignored during spell checking.\n\n\nAdditionally, you may further customize the spell-checking experience by defining \nfilters\n:\n\n\nextends\n:\n \nspelling\n\n\nmessage\n:\n \nDid\n \nyou\n \nreally\n \nmean\n \n%s\n?\n\n\nlevel\n:\n \nerror\n\n\n# This disables the built-in filters. If you omit this key or set it to false,\n\n\n# custom filters (see below) are added on top of the built-in ones.\n\n\n#\n\n\n# By default, Vale includes filters for acronyms, abbreviations, and numbers.\n\n\ncustom\n:\n \ntrue\n\n\n# A \nfilter\n is a regular expression specifying words to ignore during spell\n\n\n# checking.\n\n\nfilters\n:\n\n  \n-\n \n[pP]y.*\\b\n  \n# Ignore all words starting with \npy\n -- e.g., \nPyYAML\n.\n\n\nignore\n:\n \nci/vocab.txt", 
            "title": "Custom Styles"
        }, 
        {
            "location": "/styles/#introduction", 
            "text": "Vale is built around the notion of \"styles,\" which are directories containing individual \"rule\" definitions for example, you might have a structure like  styles/\n\u251c\u2500\u2500 base/\n\u2502   \u251c\u2500\u2500 ComplexWords.yml\n\u2502   \u251c\u2500\u2500 SentenceLength.yml\n\u2502   ...\n\u251c\u2500\u2500 blog/\n\u2502   \u251c\u2500\u2500 TechTerms.yml\n\u2502   ...\n\u2514\u2500\u2500 docs/\n    \u251c\u2500\u2500 Branding.yml\n    ...  where  base ,  blog , and  docs  are your styles. The  YAML  files are rule definitions that include the following keys:   extends : The type of check you're extending (see  Creating a Style ).  message : A message to be displayed to the user.  level : A severity level (suggestion, warning, or error).  scope : The type of text the rule operates on (see  Formats  to learn about scoping).  code :  true  to include the content of code spans and  false  (the default) to ignore them.   Many checks also include their own specific settings, which are discussed in more detail below.", 
            "title": "Introduction"
        }, 
        {
            "location": "/styles/#creating-a-style", 
            "text": "checks  offer a high-level way to extend Vale. They perform operations such as checking for consistency, counting occurrences, and suggesting changes.  Vale  and its  reference styles  are examples of how you can write your own rules.   NOTE  Vale uses Go's  regexp  package  to evaluate all patterns in rule definitions. This means that lookarounds and backreferences are not supported.", 
            "title": "Creating a Style"
        }, 
        {
            "location": "/styles/#existence", 
            "text": "extends :   existence  message :   Consider   removing   %s  ignorecase :   true  level :   warning  tokens : \n   -   appear to be \n   -   arguably   The most common extension point is the  existence  check. As its name implies, it looks for the  existence  of particular strings.  You may define these strings as elements of lists named either  tokens  or  raw . The former converts its elements into a word-bounded group by default. For instance,  message :   Consider   removing   %s  tokens : \n   -   foo \n   -   bar \n   -   baz  \nbecomes  \\b(?:foo|bar|baz)\\b . You can also use the keys  ignorecase  and  nonword  to add  (?!)  and drop the word boundaries, respectively.  raw , on the other hand, simply concatenates its elements so, something like  raw : \n   -   (?:foo)\\sbar \n   -   (baz)  \nbecomes  (?:foo)\\sbar(baz) .  An  existence  expects its  message  to include a  %s  format specifier, which will be populated with the matched string. So, using the above example, \"Consider removing 'foo'\" will be printed if we find an occurrence of \"foo.\"", 
            "title": "existence"
        }, 
        {
            "location": "/styles/#substitution", 
            "text": "extends :   substitution  message :   Consider using  %s  instead of  %s  ignorecase :   true  level :   warning  swap : \n   abundance :   plenty \n   accelerate :   speed up   A  substitution  check associates a string with a preferred form. If we want to suggest the use of \"plenty\" instead of \"abundance,\" for example, we'd write:  swap : \n   abundance :   plenty   The keys may be regular expressions, but they can't include nested capture groups:  swap : \n   (?:give|gave)   rise   to :   lead to   # this is okay \n   (give|gave)   rise   to :   lead to   # this is bad!   Like the  existence  check,  substitution  accepts the keys  ignorecase  and  nonword .  A  substitution  check can have one or two  %s  format specifiers in its  message . This allows us to do either of the following:  message :   Consider   using   %s   instead   of   %s  # or  message :   Consider   using   %s", 
            "title": "substitution"
        }, 
        {
            "location": "/styles/#occurrence", 
            "text": "extends :   occurrence  message :   Sentences   should   be   less   than   25   words  scope :   sentence  level :   suggestion  max :   25  token :   \\b(\\w+)\\b   An  occurrence  check limits the number of times a particular token can appear in a given scope. In the example above, we're limiting the number of words per sentence.  This is the only check that doesn't accept a format specifier in its message.", 
            "title": "occurrence"
        }, 
        {
            "location": "/styles/#repetition", 
            "text": "extends :   repetition  message :   %s   is   repeated!  level :   error  scope :   paragraph  ignorecase :   true  tokens : \n   -   \\b(\\w+)\\b   A  repetition   check  looks for repeated occurrences of its tokens. If  ignorecase  is set to  true , it'll convert all tokens to lower case for comparison purposes.", 
            "title": "repetition"
        }, 
        {
            "location": "/styles/#consistency", 
            "text": "extends :   consistency  message :   Inconsistent   spelling   of   %s  level :   warning  scope :   text  ignorecase :   true  either : \n   advisor :   adviser \n   centre :   center   A  consistency  check will ensure that a key and its value (e.g., \"advisor\" and \"adviser\") don't both occur in its scope.", 
            "title": "consistency"
        }, 
        {
            "location": "/styles/#conditional", 
            "text": "extends :   conditional  message :   %s   has   no   definition  level :   warning  scope :   text  first :   \\b([A-Z]{3,5})\\b  second :   (?:\\b[A-Z][a-z]+ )+\\(([A-Z]{3,5})\\)  exceptions : \n   -   ABC   A  conditional  check ensures that the existence of  first  implies the existence of  second . For example, consider the following text:    According to Wikipedia, the World Health Organization (WHO) is a specialized agency of the United Nations that is concerned with international public health. We can now use WHO because it has been defined, but we can't use DAFB because people may not know what it represents. We can use  DAFB  when it's presented as code, though.    Running  vale  on the above text with our example rule yields the following:  test.md:1:224:vale.UnexpandedAcronyms: DAFB  has no definition  A  conditional  check also takes an optional  exceptions  list. Any token listed as an exception won't be flagged.", 
            "title": "conditional"
        }, 
        {
            "location": "/styles/#capitalization", 
            "text": "extends :   capitalization  message :   %s   should   be   in   title   case  level :   warning  scope :   heading  # $title, $sentence, $lower, $upper, or a pattern.  match :   $title  style :   AP   # AP or Chicago; only applies when match is set to $title.   capitalization  checks that the text in the specified scope matches the case\nof  match . There are a few pre-defined variables that can be passed as matches:    $title : \"The Quick Brown Fox Jumps Over the Lazy Dog.\"  $sentence : \"The quick brown fox jumps over the lazy dog.\"  $lower : \"the quick brown fox jumps over the lazy dog.\"  $upper : \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\"   Additionally, when using  match: $title , you can specify a style of either  AP  or Chicago .", 
            "title": "capitalization"
        }, 
        {
            "location": "/styles/#readability", 
            "text": "extends :   readability  message :   Grade   level   (%s)   too   high!  level :   warning  grade :   8  metrics : \n   -   Flesch-Kincaid \n   -   Gunning Fog   readability  calculates a readability score according the specified metrics.\nThe supported tests are Gunning Fog, Coleman-Liau, Flesch-Kincaid, SMOG, and\nAutomated Readability.  If more than one is listed (as seen above), the scores will be averaged. This is\nalso the only extension point that doesn't accept a  scope , as readability is\nalways calculated using the entire document.  grade  is the highest acceptable score. Using the example above, a warning will\nbe issued if  grade  exceeds 8.", 
            "title": "readability"
        }, 
        {
            "location": "/styles/#spelling", 
            "text": "extends :   spelling  message :   Did   you   really   mean   %s ?  level :   error  ignore :   ci/vocab.txt   spelling  implements spell checking based on Hunspell-compatible dictionaries. By default, Vale includes  en_US-web an up-to-date, actively maintained dictionary. However, you may also specify your own via the  dic  and  aff  keys (the fully-qualified paths are required; e.g.,  /usr/share/hunspell/en_US.dic ).  spelling  also accepts an  ignore  file, which consists of one word per line to\nbe ignored during spell checking.  Additionally, you may further customize the spell-checking experience by defining  filters :  extends :   spelling  message :   Did   you   really   mean   %s ?  level :   error  # This disables the built-in filters. If you omit this key or set it to false,  # custom filters (see below) are added on top of the built-in ones.  #  # By default, Vale includes filters for acronyms, abbreviations, and numbers.  custom :   true  # A  filter  is a regular expression specifying words to ignore during spell  # checking.  filters : \n   -   [pP]y.*\\b    # Ignore all words starting with  py  -- e.g.,  PyYAML .  ignore :   ci/vocab.txt", 
            "title": "spelling"
        }, 
        {
            "location": "/showcase/", 
            "text": "Documentation\n\n\n\n  \n\n    \nHomebrew\n\n    \nA set of style and usage guidelines for Homebrew's documentation.\n\n    \nDownload as .zip\n\n  \n\n\n\n\n\n\n  \n\n    \njQuery\n\n    \nA set of rules based on jQuery's formatting conventions and writing style.\n\n    \nDownload as .zip\n\n  \n\n\n\n\n\n\n  \n\n    \nOpenStack\n\n    \nWriting style guidelines used on the OpenStack documentation.\n\n    \nDownload as .zip\n\n  \n\n\n\n\n\nEditorial Style Guides\n\n\n\n  \n\n    \n18F\n\n    \nGuidelines for creating plain and concise writing.\n\n    \nDownload as .zip\n\n  \n\n\n\n\n\n\n  \n\n    \nMailChimp\n\n    \nWriting style guidelines created for MailChimp employees.\n\n    \nDownload as .zip\n\n  \n\n\n\n\n\n\n  \n\n    \nMiddlebury\n\n    \nA collection of rules based on The Middlebury Editorial Style Guide.\n\n    \nDownload as .zip\n\n  \n\n\n\n\n\n\n  \n\n    \nThe Economist\n\n    \nA collection of rules based on The Economist Style Guide.\n\n    \nDownload as .zip\n\n  \n\n\n\n\n\nLinters\n\n\n\n  \n\n    \nJoblint\n\n    \nTest tech job posts for issues with sexism, culture, expectations, and recruiter fails.\n\n    \nDownload as .zip\n\n  \n\n\n\n\n\n\n  \n\n    \nproselint\n\n    \nA linter for English prose that aggregates knowledge about best practices in writing.\n\n    \nDownload as .zip\n\n  \n\n\n\n\n\n\n  \n\n    \nwrite-good\n\n    \nNaive linter for English prose for developers who can't write good.\n\n    \nDownload as .zip", 
            "title": "Style Showcase"
        }, 
        {
            "location": "/showcase/#documentation", 
            "text": "", 
            "title": "Documentation"
        }, 
        {
            "location": "/showcase/#editorial-style-guides", 
            "text": "", 
            "title": "Editorial Style Guides"
        }, 
        {
            "location": "/showcase/#linters", 
            "text": "", 
            "title": "Linters"
        }, 
        {
            "location": "/examples/", 
            "text": "Continuous Integration\n\n\n\n\nVale's own documentation\n uses Vale with MkDocs, Travis CI, and GitHub Pages.\n\n\nWrite the Docs\n uses Vale with Sphinx, Travis CI, and Tox.\n\n\nLinode\n uses a combination of \npytest\n, Vale, and Travis CI.\n\n\n\n\nIn the News\n\n\n\n\nNatural language linting (Signavio)\n\n\nLinters for the English Language (DZone)", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#continuous-integration", 
            "text": "Vale's own documentation  uses Vale with MkDocs, Travis CI, and GitHub Pages.  Write the Docs  uses Vale with Sphinx, Travis CI, and Tox.  Linode  uses a combination of  pytest , Vale, and Travis CI.", 
            "title": "Continuous Integration"
        }, 
        {
            "location": "/examples/#in-the-news", 
            "text": "Natural language linting (Signavio)  Linters for the English Language (DZone)", 
            "title": "In the News"
        }
    ]
}